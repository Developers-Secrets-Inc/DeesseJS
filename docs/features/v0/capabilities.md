# DS Capability System Plan

## Product Vision

The **Capability System** in Deesse (DS) is a unified mechanism that allows plugins to expose, consume, and discover functionality without any direct coupling. It provides a typed, composable, and secure interface for cross-plugin communication.

### Core Goals

* **Decoupled extensibility**: Plugins can collaborate without knowing each other.
* **Strong typing and DX**: `ctx.capability()` is fully typed and auto-completed.
* **Security and governance**: Capabilities are sandboxed and controlled by policies.
* **Dynamic discovery**: The system automatically detects and merges all available capabilities.
* **Consistency**: The same mental model applies across all plugins.

---

## Product Overview

Capabilities represent **actions** that can be performed in the DS ecosystem — e.g. `storage.upload`, `email.send`, `analytics.track`.

A plugin may **expose** capabilities (make them available) or **consume** them (use them without direct dependency). The DS runtime serves as a broker, ensuring that calls are routed to the appropriate provider.

### Example Use Case

* **Plugin A**: Chat AI wants to store its conversation data.
* **Plugin B**: S3 Storage plugin provides `storage.upload` capability.

`Plugin A` simply calls:

```ts
await ctx.capability("storage.upload")({ path: "chats/123.json", data: chat });
```

DS automatically resolves the proper plugin that implements `storage.upload`.

---

## Developer Experience (DX)

### 1. Declaring a Capability

A plugin declares its available capabilities using a static definition:

```ts
export const plugin = definePlugin({
  name: "@deesse/storage-s3",
  capabilities: {
    "storage.upload": defineCapability<
      { path: string; data: Blob | string; contentType?: string },
      { url: string }
    >(),
  },
});
```

This declaration:

* Creates a **runtime binding** for DS.
* Registers **type metadata** for build-time code generation.

### 2. Typing and Autocompletion

During build, DS merges all plugin declarations into a generated type map:

```ts
// .deesse/generated/capabilities.d.ts
declare module "deesse" {
  export interface CapabilityMap {
    "storage.upload": (args: {
      path: string;
      data: Blob | string;
      contentType?: string;
    }) => Promise<{ url: string }>;
  }
}
```

Developers then get autocompletion and strong typing:

```ts
const upload = ctx.capability("storage.upload");
await upload({ path: "a/b.txt", data: "Hello" });
```

### 3. Consuming a Capability

Any plugin can access an available capability:

```ts
const send = ctx.capability("email.send");
await send({ to: user.email, subject: "Welcome", html });
```

If the capability is missing, DS throws a descriptive error or logs a policy violation.

### 4. Policy & Security Layer

* **Capability scopes** define what a plugin can expose or consume.
* **Trust tiers** (`core`, `official`, `community`) limit sensitive scopes.
* **Runtime policies** can block, throttle, or audit access to capabilities.

Example:

```ts
definePolicy({
  scope: "storage.upload",
  allow: (ctx, origin) => origin.tier !== "community",
});
```

### 5. DX Enhancements

* Autogenerated documentation in Admin Dashboard showing available capabilities, their sources, and schemas.
* CLI tools:

  ```bash
  npx deesse capabilities:list
  ```
* Type-safe resolution: compile-time error if capability doesn’t exist.
* Hot reload of capabilities during plugin installation.

---

## Architecture Overview

```
┌───────────────────────────────┐
│ Plugin (Provider)             │
│  exposes capabilities         │
│  → storage.upload             │
└────────────┬──────────────────┘
             │ register
             ▼
┌───────────────────────────────┐
│ DS Capability Registry        │
│  merges definitions           │
│  validates with policies      │
│  exposes to runtime ctx       │
└────────────┬──────────────────┘
             │ resolve
             ▼
┌───────────────────────────────┐
│ Plugin (Consumer)             │
│  ctx.capability("storage.upload") │
│  → fully typed + secure call   │
└───────────────────────────────┘
```

---

## Developer Value

* **Ease of integration:** Add new capabilities by writing a single declaration.
* **Safety:** Full static typing ensures no runtime surprises.
* **Scalability:** New plugins can replace or extend existing ones transparently.
* **Observability:** Every capability call is traceable and can trigger events.
* **Consistency:** Unified API for all plugin-to-plugin interactions.

---

## Future Directions

* Capability discovery in DevTools (visual graph view).
* AI-assisted autocomplete (suggests relevant capabilities).
* Capability families (e.g. `storage.*`, `email.*`).
* Remote capabilities (cross-instance DS communication).

---

### TL;DR

> **Capabilities = the communication language of DS.**
>
> They unify plugin interoperability, enforce security, and give developers a perfectly typed, zero-coupling API.
