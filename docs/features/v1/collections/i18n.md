# DeesseJS Localization System (v1)

## Overview

The **Localization System** in DeesseJS provides a unified way to manage multilingual content and interfaces.
It enables developers to:

1. Translate the **Admin interface** (labels, descriptions, placeholders, etc.)
2. Localize **content fields** (text, rich text, etc.) for multiple user-facing languages.

The system is designed to be **dynamic**, **declarative**, and **backend-agnostic**, allowing both plugin developers and end users to define, edit, and render content across multiple locales seamlessly.

---

## Core Concept

Localization in DeesseJS is divided into two complementary layers:

| Layer                                   | Description                                                                | Example                                 |
| --------------------------------------- | -------------------------------------------------------------------------- | --------------------------------------- |
| **Admin Localization (Interface i18n)** | Translates labels, descriptions, and UI elements in the admin dashboard    | `"Name" → "Nom" → "Nombre"`             |
| **Content Localization (Data i18n)**    | Allows field values (text, rich text, etc.) to exist in multiple languages | `title: { en: "Hello", fr: "Bonjour" }` |

Both systems rely on a **shared global configuration** of available languages and a default locale.

---

## Global Localization Configuration

```typescript
localization: {
  enabled: true;
  defaultLocale: "en";
  locales: ["en", "fr", "es"];
  strategy: "per-field"; // or "per-record"
}
```

* **enabled** — toggles the localization system.
* **defaultLocale** — fallback language when a translation is missing.
* **locales** — list of active languages.
* **strategy** — determines how localized data is stored:

  * `"per-field"` — each field stores translations (JSONB structure).
  * `"per-record"` — each record represents a single locale (duplicated entries).

---

## Admin Localization (Interface i18n)

### Goal

When an admin user switches language, all UI labels, placeholders, and descriptions automatically display in that language.

### Declaration Example

```typescript
fields: {
  name: field({
    type: text(),
    admin: {
      label: {
        en: "Name",
        fr: "Nom",
        es: "Nombre",
      },
      description: {
        en: "Full name of the user",
        fr: "Nom complet de l'utilisateur",
      },
    },
  }),
}
```

### Behavior

* The admin dashboard automatically detects the active locale.
* The correct translation is resolved dynamically.
* Missing translations gracefully fallback to the `defaultLocale`.

### Global Dictionary Mode

For reusable translations across the admin interface:

```typescript
// locales/admin.ts
export const locales = {
  en: { fields: { name: "Name" }, collections: { users: "Users" } },
  fr: { fields: { name: "Nom" }, collections: { users: "Utilisateurs" } },
};

// field definition
admin: { labelKey: "fields.name" };
```

Deesse resolves `labelKey` at runtime using the current admin locale.

---

## Content Localization (Data i18n)

### Goal

Allow developers to mark specific fields as *localized*, enabling multilingual values at the data layer.

### Declaration Example

```typescript
fields: {
  title: field({
    type: text(),
    localized: true, // field-level flag
  }),
  content: field({
    type: richText(),
    localized: true,
  }),
  author: field({
    type: relation({ target: "users" }), // not localized
  }),
}
```

---

## Field Behavior

When `localized: true` is set, Deesse automatically transforms the field’s internal structure:

| Layer                 | Behavior                                                                                                   |
| --------------------- | ---------------------------------------------------------------------------------------------------------- |
| **Schema (Zod)**      | Replaces `z.string()` with `z.record(z.string())` — e.g. `{ en: string; fr?: string }`                     |
| **Storage (Drizzle)** | Stores translations in a JSONB column (`{ en: "...", fr: "..." }`) or via a join table for advanced setups |
| **Admin UI**          | Renders language tabs or dropdown selectors for input fields                                               |
| **Cache & API**       | Keys and responses include the locale context (`posts:fr:123`)                                             |

---

## Strategy: per-field vs per-record

| Strategy       | Description                                             | Example                              | Pros                     | Cons                         |
| -------------- | ------------------------------------------------------- | ------------------------------------ | ------------------------ | ---------------------------- |
| **Per-field**  | Each field contains localized values (as a JSON object) | `{ title: { en: "...", fr: "..." }}` | Flexible, no duplication | Slightly more complex schema |
| **Per-record** | Each locale stored as a separate record                 | `posts_en`, `posts_fr`               | Simple queries           | Duplicated data, harder sync |

Deesse defaults to the **per-field** strategy for simplicity and composability.

---

## Fallback Logic

If a translation is missing for a given locale:

* Deesse falls back to `defaultLocale` (e.g. English).
* The admin visually marks missing translations (e.g. colored tab indicator).

---

## API Layer Integration

All localized fields are automatically filtered and resolved based on locale:

| Request                | Response                                         |
| ---------------------- | ------------------------------------------------ |
| `/api/posts?locale=fr` | Returns `{ title: "Titre", content: "Contenu" }` |
| `/api/posts?locale=en` | Returns `{ title: "Title", content: "Content" }` |

If no `locale` is specified, Deesse uses the default locale.

Developers can also query raw translations via:

```typescript
GET /api/posts?include=translations
```

---

## Admin UI Experience

### 1. Localized Field Component

Each localized field renders:

* A **tabbed interface** (one per locale)
* Automatic fallback handling
* Validation per language
* Visual indicators for missing translations

Example:

```
[Français] [English] [Español]
┌───────────────────────────────┐
| [EN] Title: "Hello World"     |
| [FR] Title: "Bonjour le monde"|
└───────────────────────────────┘
```

### 2. Dynamic Locale Switching

The admin dashboard language switcher affects both:

* UI text (labels, menus, buttons)
* Default editing locale for localized fields

---

## Developer Experience (DX)

1. **Declarative** — add `localized: true` to any field type.
2. **Automatic Schema Derivation** — Zod + Drizzle handle all locale mappings.
3. **Unified Config** — one localization config for both admin and data.
4. **Plugin Extensibility** — plugins can register additional locales or provide custom UI.
5. **Predictable Fallbacks** — no manual handling for missing translations.
6. **Language-Aware Caching & API** — locale automatically propagates to cache keys and endpoints.

---

## Integration Points

| System               | Role of Localization                               |
| -------------------- | -------------------------------------------------- |
| **Fields**           | Adds `localized()` wrapper around field primitives |
| **Collections**      | Defines which locales are active                   |
| **Admin**            | Provides language-aware labels and inputs          |
| **Zod Compiler**     | Expands field schemas per locale                   |
| **Drizzle Compiler** | Maps fields to JSONB or relational schema          |
| **Cache**            | Locale-prefixed keys for isolation                 |
| **API Layer**        | Filters and serves locale-specific data            |
| **Plugins**          | Can inject translations or override locale logic   |

---

## Design Philosophy

1. **Single Source of Truth:** one localization config for the whole system.
2. **Field-Level Opt-In:** only fields that need translations are localized.
3. **Declarative Overhead:** no imperative i18n logic; everything inferred from config.
4. **Composable and Extensible:** plugins and projects can expand locales dynamically.
5. **Backend-Agnostic:** JSON or SQL representation, both supported.

---

## Future Directions (post-v1)

| Area                             | Description                                                             |
| -------------------------------- | ----------------------------------------------------------------------- |
| **Nested Localization**          | Support localized arrays and objects (e.g. `array(text().localized())`) |
| **Localization Plugins**         | External language providers (DeepL, Google Translate, etc.)             |
| **Namespace-level localization** | Different locales per tenant or app namespace                           |
| **Versioning integration**       | Track translation changes over time                                     |
| **Admin UI enhancements**        | Inline translation preview, auto-suggest, missing translation reports   |
| **Field-level fallbacks**        | Define custom fallback chains (`fr → en → es`)                          |

---

## Summary

| Goal                       | Description                         |
| -------------------------- | ----------------------------------- |
| Unified localization layer | Consistent across admin and content |
| Simple field opt-in        | `localized: true` flag              |
| Admin translations         | Dynamic UI language switching       |
| Per-field strategy         | JSONB or in-memory per field        |
| API + cache integration    | Locale-aware responses and keys     |
| Extensible core            | Plugin-ready i18n architecture      |
