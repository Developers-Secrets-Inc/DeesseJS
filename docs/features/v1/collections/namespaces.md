# DeesseJS Namespace System (v1)

## Overview

The **Namespace System** in DeesseJS introduces logical isolation and contextual grouping for collections, fields, and data across the entire framework.
A **namespace** represents a unique *logical space* within the Deesse runtime — allowing projects to separate data domains, applications, tenants, or plugins without collision or coupling.

Namespaces are designed to be **conceptual**, not just database-level.
They influence how data, cache keys, relations, and admin views are scoped — while remaining backend-agnostic and functionally composable.

---

## Core Concept

A **namespace** defines *where* a collection exists and *to which domain it belongs*.
It can represent:

* A tenant (`tenant_42`)
* An application module (`shop`, `blog`)
* A plugin domain (`@deesse/audit`)
* An environment (`staging`, `production`)

Namespaces provide structural separation **across all layers** of Deesse:

| Layer              | Role of namespace                                |
| ------------------ | ------------------------------------------------ |
| **Database**       | Maps to a PostgreSQL schema or table prefix      |
| **Cache**          | Prefix for Redis and in-memory cache keys        |
| **Admin UI**       | Logical grouping of collections in the dashboard |
| **API**            | URL scoping for routes (`/namespace/collection`) |
| **Access Control** | Context boundary for permissions and rules       |
| **Plugins**        | Isolation for internal or third-party extensions |

---

## Example Usage

```typescript
import { collection } from "deesse/collections";
import { field, text, relation } from "deesse/fields";

export const Products = collection({
  namespace: "shop",
  slug: "products",
  label: "Product",
  fields: {
    name: field({ type: text() }),
    description: field({ type: text() }),
    category: field({ type: relation({ target: "shop:categories" }) }),
  },
});
```

This collection belongs to the `shop` namespace, which affects:

* Database table name → `shop.products`
* Cache key → `shop:products:id`
* Admin route → `/admin/shop/products`
* API route → `/shop/products`

---

## Functional Goals

The Namespace System should:

1. **Provide logical isolation** between domains (apps, tenants, plugins)
2. **Unify naming conventions** across all internal systems
3. **Integrate natively with PostgreSQL schemas** through Drizzle
4. **Remain backend-agnostic** (works even with non-SQL adapters)
5. **Be declarative** and composable without runtime side effects
6. **Support dynamic namespaces** (multi-tenant systems)

---

## Declaration Syntax

Namespaces are declared directly in the `collection()` definition.

```typescript
collection({
  namespace: "blog",
  slug: "posts",
  fields: { ... }
});
```

The combination of `namespace + slug` forms the **fully qualified identifier** of the collection.

### Fully Qualified Identifier (FQI)

```
namespace: "blog"
slug: "posts"
→ FQI = "blog:posts"
```

This FQI becomes the base for:

* Internal lookups
* Database table names
* Cache keys
* Admin paths

---

## PostgreSQL Integration

When using Drizzle with the PostgreSQL adapter, the namespace maps directly to a database schema.

### Example

```typescript
import { pgSchema } from "drizzle-orm/pg-core";

const ns = pgSchema("shop");

const products = ns.table("products", {
  id: serial("id").primaryKey(),
  name: text("name"),
});
```

Deesse automatically handles this mapping:

```typescript
// Generated by Deesse at compile time
pgSchema(namespace).table(slug, drizzleFields);
```

Resulting SQL:

```sql
CREATE SCHEMA IF NOT EXISTS "shop";
CREATE TABLE "shop"."products" (...);
```

If the backend doesn’t support schemas, Deesse falls back to **prefix-based naming**:

```
shop__products
```

This ensures full portability across databases.

---

## Multi-Tenant and Dynamic Namespaces

Deesse supports **dynamic namespace factories** for multi-tenant environments.

```typescript
export const makeTenantCollections = (tenantId: string) => ({
  Posts: collection({
    namespace: tenantId,
    slug: "posts",
    fields: { title: field({ type: text() }) },
  }),
});
```

At runtime, each tenant gets isolated:

* Tables → `tenant_123.posts`
* Cache → `tenant_123:posts`
* API → `/tenant_123/posts`

---

## Behavior Across Systems

| Layer                  | Behavior                                                                    |
| ---------------------- | --------------------------------------------------------------------------- |
| **Database (Drizzle)** | Maps to a schema via `pgSchema(namespace)`                                  |
| **Cache System**       | Prefixes all keys: `${namespace}:${slug}`                                   |
| **Admin UI**           | Groups collections visually by namespace                                    |
| **API Layer**          | Routes include namespace prefix (`/namespace/slug`)                         |
| **Relations**          | Cross-namespace relations use fully qualified targets: `"shop:categories"`  |
| **Access Rules**       | Context object receives the active namespace: `({ namespace, user })`       |
| **Plugins**            | Each plugin can register collections in its own namespace (`@deesse/audit`) |

---

## Developer Experience (DX)

The goal is to make namespaces **automatic**, **intuitive**, and **zero-boilerplate**.

### 1. **Transparent Integration**

Developers only declare the namespace once; Deesse handles all propagation.

### 2. **Type Safety**

The namespace becomes part of the collection’s inferred type:

```typescript
type Products = SchemaType<typeof ProductsCollection>; // includes namespace
```

### 3. **Cross-Namespace Relations**

Developers can reference other namespaces explicitly:

```typescript
relation({ target: "blog:authors" });
```

### 4. **Factory Composition**

Namespaces can be dynamically created via factory functions:

```typescript
withNamespace("tenant_123", () => {
  registerCollections({ Users, Orders });
});
```

---

## Internal Representation

```typescript
type NamespaceEntity = {
  name: string;
  source?: "collection" | "plugin" | "runtime";
  strategy?: "postgres-schema" | "prefix";
};
```

`strategy` defines how the namespace is physically represented.

Deesse will provide a unified resolver:

```typescript
getPhysicalName(namespace: string, slug: string) 
// => "shop.products" or "shop__products"
```

---

## Extensibility

Namespaces will later support:

* **Nested namespaces** (e.g., `tenant:plugin:collection`)
* **Access policies per namespace**
* **Plugin-scoped namespaces**
* **Cross-namespace caching strategies**
* **Multi-database adapters**

---

## Design Philosophy

1. **Conceptual over physical:**
   Namespaces are first and foremost logical — physical mapping is derived automatically.

2. **Declarative over procedural:**
   The developer defines *what* the context is, not *how* it’s implemented.

3. **Isolated but composable:**
   Each namespace is fully independent, but still interoperable through fully qualified names.

4. **Backend-agnostic:**
   Whether PostgreSQL, SQLite, or in-memory — namespaces always exist at the framework level.

---

## Future Directions (post-v1)

| Area                           | Description                                                  |
| ------------------------------ | ------------------------------------------------------------ |
| **Cross-namespace relations**  | Ability to query and join across namespaces                  |
| **Admin multi-namespace view** | Switch or merge namespace contexts in the dashboard          |
| **Tenant discovery**           | Register new namespaces dynamically at runtime               |
| **Namespace permissions**      | Access control scoped at the namespace level                 |
| **Namespace event routing**    | Event bus topics automatically include namespace identifiers |
| **Namespace-aware migrations** | Generate schema migrations per namespace automatically       |

---

## Summary

| Goal                   | Description                                                        |
| ---------------------- | ------------------------------------------------------------------ |
| Unified abstraction    | A single concept of logical isolation across DB, cache, API, admin |
| PostgreSQL integration | Uses native `pgSchema()` support for schema-level separation       |
| Dynamic support        | Factories and runtime namespaces for multi-tenant systems          |
| Backend agnostic       | Works with or without SQL schemas                                  |
| DX-first design        | Declarative, type-safe, automatic propagation                      |
| Extensible core        | Plugins and systems can define their own namespaces                |
